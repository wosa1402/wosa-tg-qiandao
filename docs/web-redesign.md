# TG Signer Web 方案重新设计（候选方案集）

> 目标：在移除旧 WebUI 后，重新设计一套“可用、可维护、可扩展”的 Web 交互方案。
>
> 当前进度：已按最终选型落地 MVP 骨架（单层账号登录、任务管理、子进程运行、SSE 日志、WebDAV 备份）；快速开始见 `docs/web-quickstart.md`。
>
> 说明：本文中的 BasicAuth/双层鉴权章节为历史方案记录，当前实现已改为单层管理员登录。

## 1. 背景与问题陈述

- 现状：项目曾提供 WebUI（基于 NiceGUI），但交互体验与可维护性不符合预期，因此已在仓库中移除。
- 痛点（推测 + 待确认）：
  - 配置流程不够“向导化”，用户容易迷失在大量字段中。
  - 运行状态、日志、错误定位不够直观（缺少可观测性）。
  - “一次性动作/长期运行监控/定时任务”三类能力在 UI 中的心智模型不清晰。
  - 安全边界不明确（session、授权码、工作目录等敏感信息的暴露风险）。

## 2. 设计目标（用户价值）

### 2.1 核心体验目标

- 配置：用“向导/表单 + 高级模式（YAML/JSON）”双通道完成任务配置。
- 运行：一键运行/停止/重跑，清晰展示执行进度与结果（成功/失败原因）。
- 观测：实时日志、关键事件、历史记录可查询；支持导出用于排障。
- 多账号：同一套配置跑多个账号，状态可区分、可对比。

### 2.2 非功能目标（工程属性）

- 可维护：UI 与核心逻辑解耦；Web 只做展示与编排，不直接“写业务逻辑”。
- 可扩展：未来接入更多动作类型/监控规则时，UI 改动可控。
- 安全：默认只监听 `127.0.0.1`；敏感信息最小暴露；可选鉴权。
- 部署：优先支持“本机自用”；可选 Docker/局域网部署。

## 3. 建议的统一底座（与方案无关，强烈建议先达成共识）

无论选哪套 Web 技术栈，都建议先明确下面 4 个“产品内核”：

1) 领域服务层（Service Layer）
- 把“列出任务/读取配置/保存配置/运行任务/停止任务/查询状态”等能力封装成稳定接口。
- CLI 与 Web 共用该层，避免出现“两套逻辑”。

2) 任务执行模型（Job Runner）
- 典型两种：同进程 `asyncio` 任务；或子进程/队列（更隔离、更稳）。
- 需要定义：任务状态机（pending/running/success/failed/stopped）、取消语义、重试策略。

3) 状态与记录存储（State Store）
- 最小可行：沿用 `--workdir` 目录（文件 + JSON/YAML）。
- 中期升级：SQLite（索引查询更友好；并发安全更好）。

4) 可观测性（Observability）
- 日志：按任务/账号维度聚合；Web 能实时订阅（WebSocket/SSE）。
- 事件：关键动作记录（开始/结束/失败原因/外部调用耗时）。

## 4. 候选方案总览（供选择）

| 方案 | 技术栈 | 体验上限 | 工程复杂度 | 最适用场景 | 主要风险 |
|---|---|---:|---:|---|---|
| A. FastAPI + Jinja2 + HTMX | 纯 Python、少量 JS | 中 | 低 | 本机自用/小团队 | 复杂交互会逐步变重 |
| B. FastAPI + Vue3/React SPA | REST/WS + SPA + 组件库 | 高 | 中-高 | 追求最佳体验、可多人使用 | 前端工程化与维护成本 |
| C. Streamlit/Gradio 内部工具 | 全 Python 快速 UI | 中-低 | 低 | 快速可用、个人工具 | 自定义与状态管理受限 |
| D. “桌面壳”Tauri/Electron + 本地后端 | Web 技术 + 本地应用形态 | 高 | 高 | 更像“客户端”的体验 | 打包/更新/跨平台复杂度 |

下面分别展开说明（均为设计，不包含实现细节）。

---

## 5. 方案 A：FastAPI + Jinja2 + HTMX（轻量、强推荐起步）

### 5.1 架构形态

- 一个 Python 服务：
  - HTTP：页面渲染（Jinja2）
  - API：同域 `/api/*`（给页面的异步交互用）
  - 实时：SSE 或 WebSocket（日志/状态推送）

### 5.2 页面与信息架构（IA）

- 首页 Dashboard：今天运行情况、失败任务、最近日志摘要
- 任务管理：
  - 任务列表（按类型：签到/监控/动作流）
  - 任务详情：配置概览、最近运行记录、运行按钮
  - 任务编辑：向导模式 + 高级 YAML/JSON 编辑
- 账号管理：
  - 账号列表（account 名、session 存储位置、最后登录时间）
  - 导入 session-string（只在本机使用时建议）
- 记录/日志：
  - 运行历史（可筛选账号/任务/状态）
  - 实时日志（按运行实例订阅）

### 5.3 优点

- 纯 Python：开发与部署最简单，和现有项目契合度最高。
- 交互够用：HTMX 能覆盖绝大多数“表单提交 + 局部刷新”的需求。
- 可渐进：后续如果要升级为 SPA，API 可以直接复用。

### 5.4 缺点/风险

- 复杂交互（复杂表单联动、拖拽编排、图形化流程）成本会上升。
- 模板多了以后需要规范化组织（组件化模板、统一布局）。

### 5.5 适用结论

如果你更在意“尽快做出一个真正好用的界面”，且主要是本机/小范围使用，方案 A 是成本收益比最高的起步方案。

---

## 6. 方案 B：FastAPI + Vue3/React SPA（体验上限最高）

### 6.1 架构形态

- 后端（Python/FastAPI）：
  - REST：配置/任务/记录
  - WebSocket：日志流、任务状态推送
- 前端（Vue3/React）：
  - 组件库：Element Plus / Naive UI / Ant Design（择一）
  - 路由/状态管理：Pinia/Redux

### 6.2 关键交互能力（相比方案 A 的增量）

- 配置编辑器体验更强：
  - 分步向导 + 即时校验（基于后端的 Pydantic 校验结果）
  - 高级模式：Monaco Editor（类 VSCode 编辑器）
- 更强的可视化：
  - 运行趋势图、错误聚类、耗时分布
  - 多账号并行运行看板
- 更容易做“编排器”：
  - 动作流可视化编辑（拖拽/节点图）

### 6.3 优点

- 最佳用户体验，长期演进空间最大。
- 前端生态成熟，复杂交互更容易“做得像样”。

### 6.4 缺点/风险

- 工程化成本：构建、发布、静态资源托管、版本兼容需要一套流程。
- 团队要求：需要有人维护前端工程（依赖升级、组件库变更、构建链）。

### 6.5 适用结论

如果你的目标是“长期主力入口”且希望做到接近商业产品体验，方案 B 是最优，但需要接受更高的开发与维护成本。

---

## 7. 方案 C：Streamlit/Gradio（最快可用的内部工具）

### 7.1 架构形态

- 单 Python 进程直接起 UI（Streamlit/Gradio）
- 通过调用 Service Layer 读写配置、触发任务

### 7.2 优点

- 极快交付：适合迅速把“配置 + 运行 + 看日志”跑通。
- 人力要求低：基本全 Python 即可。

### 7.3 缺点/风险

- 自定义交互与布局受框架约束，越做越“别扭”。
- 复杂状态管理与权限体系不擅长。

### 7.4 适用结论

如果你希望“1-2 周内先有个能用的界面”，且主要自用，方案 C 非常合适；但中长期可能要迁移到 A 或 B。

---

## 8. 方案 D：Tauri/Electron 桌面壳（像客户端一样好用）

### 8.1 架构形态

- UI：Web 技术（React/Vue）
- 本地壳：Tauri（更轻）或 Electron（生态更成熟）
- 本地后端：Python 服务（或把核心直接做成库调用）

### 8.2 优点

- 体验接近原生客户端：启动快、可托盘、通知、自动更新等。
- 对“本机自用”非常友好：不需要开放端口给浏览器以外的访问。

### 8.3 缺点/风险

- 打包与分发复杂：Python + 前端 + 壳三件套，需要明确发布策略。
- 跨平台适配成本高（尤其 Windows/macOS 签名、权限等）。

### 8.4 适用结论

如果你更想要“桌面客户端体验”而不是浏览器，且有明确的分发诉求，可以考虑；否则不建议作为第一选择。

---

## 9. 推荐路线（折中且稳）

### 推荐 1（稳妥起步）：A →（验证需求后）B

1) 先做方案 A，把信息架构与 Service Layer 打磨到“真正好用”
2) 当你明确需要复杂交互/多人协作时，再升级为方案 B（API 可复用）

### 推荐 2（极致速度）：C → A

1) 用方案 C 快速落地工作流，尽快验证交互与字段设计
2) 需求稳定后迁移到方案 A 获取更好可控性

## 10. 需要你确认的关键问题（决定选型）

1) Web 是否只在本机使用？还是要局域网/公网访问？
2) 是否需要“多用户 + 权限”？还是单用户即可？
3) 配置编辑主要是“表单向导”，还是你想要“可视化动作编排器”？
4) 日志是否需要实时流式展示？是否需要保存并按条件检索？
5) 账号/session 的管理方式：导入 session-string 是否可接受？是否要 Web 里做登录？
6) 你更看重：尽快可用（A/C）还是体验上限（B）？
7) 是否接受引入前端工程（Node、构建、组件库）？

---

## 11. 下一步建议（你选方案后我再细化）

- 你先从 A/B/C/D 里选一个主方案（也可选“路线：A→B”）。
- 我会基于你的选择补一份更细的设计文档：
  - 信息架构（页面路由/导航）
  - API 草案（接口列表/请求响应/鉴权）
  - 任务状态机与日志流设计
  - 安全与部署方案（本机/局域网/Docker）

---

## 12. 已确认的选型输入（来自当前需求）

- 部署方式：云服务器 + 绑定域名（公网访问），后续 Docker 部署。
- 权限模型：单用户。
- 账号管理：希望直接在 Web 中添加/登录 Telegram 账号（不依赖终端交互）。
- 使用链路：暂无既定习惯，需要先把核心流程跑通再迭代。
- 部署细节约束：平台提供 HTTPS 域名绑定端口；无白名单；无持久化卷（可用 WebDAV 备份/拉取）。

## 13. 选型结论（采纳）

### 13.1 路线选择：A → B（先落地 A）

- 第一阶段：方案 A（FastAPI + Jinja2 + HTMX + SSE/WS），目标是“功能可用 + 流程顺畅 + 可观测性完整”。
- 第二阶段：如确实需要复杂交互/更强可视化，再升级为方案 B（SPA），复用后端 API 与任务/状态底座。

> 你提到“前期注重功能，UI 后期优化”是对的；但需要强调：前期要把“信息架构、数据模型、API 合约、任务状态机、日志与安全边界”
> 定下来，这些决定会直接影响后期 UI 能否平滑升级（不然 UI 优化会变成大重构）。

## 14. 第一阶段详细设计（方案 A 的落地蓝图，设计稿）

本节只描述“应当怎么做”，不涉及实现细节与代码。

### 14.1 运行形态：Web 控制台取代 CLI

- 目标：日常使用只通过 Web 完成（账号登录、配置管理、运行与监控、查看日志/历史）。
- CLI 的定位：保留为“应急/低层工具”，但不是主要入口（甚至可不对外宣传）。

建议的进程模型（适配 Docker）：

- `app` 容器内：1 个 Web 主进程 + N 个按需 worker 子进程
  - Web（FastAPI）负责页面 + API + 日志流
  - WorkerManager 负责创建运行实例、拉起/停止/监督 worker 子进程（已选路线 Y，见 14.6）
- 外层入口（平台 Ingress 或 Nginx/Caddy）：
  - TLS/HTTPS（平台托管或自行终止）
  - 访问控制（已选“两层鉴权”，见 14.5）

### 14.2 信息架构（页面/导航）

最小可用版本（MVP）页面建议：

- `/` 仪表盘
  - 当前运行中的任务数、最近失败、最近 20 条关键事件
- `/accounts` 账号管理
  - 账号列表（account 名、是否已登录、最后登录时间）
  - 添加账号向导（手机号→验证码→二次密码）
  - 登出/删除 session
- `/tasks` 任务列表
  - 任务（配置）列表：任务名、类型（签到/监控/工具）、关联账号、启用状态
- `/tasks/{task}` 任务详情
  - 配置概览（只读）
  - 运行按钮：运行/运行一次/停止（按任务类型展示）
  - 最近运行记录（run 列表）
- `/tasks/{task}/edit` 任务编辑
  - 向导模式（推荐默认）
  - 高级模式（JSON/YAML 直接编辑 + 校验错误定位）
- `/runs` 运行历史
  - 条件筛选（账号/任务/状态/时间）
- `/runs/{run_id}` 运行详情
  - 状态、开始/结束、错误原因、日志流

### 14.3 核心领域对象（数据模型草案）

> 这里只是“系统视角的稳定对象”，不等同于当前 `config.json` 的具体结构；但建议映射得足够直接，避免二次建模带来的维护成本。

- Account（Telegram 账号实例）
  - `account_name`（对应当前项目的 `--account`）
  - `session_dir`（建议固定为容器卷内路径，如 `/data/sessions`）
  - `status`：`logged_out | logging_in | logged_in | error`
  - `last_login_at`、`last_error`
- Task（任务配置）
  - `task_name`（对应 `workdir/signs/{task}/`）
  - `type`：`signer | monitor | utility`
  - `enabled`（是否随服务启动自动运行）
  - `config`（JSON，直接复用当前配置结构；保存时做 Pydantic 校验）
- Run（一次运行实例）
  - `run_id`（UUID）
  - `task_name`、`account_name`
  - `mode`：`run | run_once | monitor`
  - `status`：`queued | running | success | failed | stopped`
  - `started_at`、`finished_at`、`error_message`
  - `log_path`（或日志索引 key）

### 14.4 API 草案（仅列接口，后续可细化请求/响应）

账号（登录向导分步式）：

- `POST /api/accounts`：创建 account（仅创建，不登录）
- `POST /api/accounts/{account}/login/start`：提交手机号，触发发送验证码
- `POST /api/accounts/{account}/login/verify`：提交验证码
- `POST /api/accounts/{account}/login/password`：提交二次密码（如需要）
- `POST /api/accounts/{account}/logout`：登出并删除 session
- `GET  /api/accounts`：账号列表与状态

任务与配置：

- `GET  /api/tasks`：列出任务
- `POST /api/tasks`：创建任务（可从模板/导入）
- `GET  /api/tasks/{task}`：任务详情
- `PUT  /api/tasks/{task}`：保存配置（后端校验，返回字段级错误）
- `POST /api/tasks/{task}/export`：导出配置
- `POST /api/tasks/{task}/import`：导入配置

运行与日志：

- `POST /api/tasks/{task}/run`：运行（对应 CLI run）
- `POST /api/tasks/{task}/run-once`：运行一次
- `POST /api/runs/{run_id}/stop`：停止运行
- `GET  /api/runs`：运行历史
- `GET  /api/runs/{run_id}`：运行详情
- `GET  /api/runs/{run_id}/logs`：拉取日志片段
- `GET  /api/runs/{run_id}/logs/stream`：日志流（SSE 或 WebSocket）

> 关键原则：页面的交互都走 API，避免把业务写进模板；这样未来升级 SPA 只需换前端，不需要重写后端逻辑。

### 14.5 安全设计（公网部署必须重视）

单用户也要做“强保护”，否则域名一暴露就等于把 Telegram session 暴露在互联网上：

- 强制 HTTPS（推荐 Nginx/Caddy 终止 TLS）。
- 访问鉴权（已选：两层叠加）：
  - 外层：反向代理 BasicAuth（先挡住绝大多数扫描与爆破）
  - 内层：应用内登录（密码 + 安全 Cookie 会话），用于细粒度保护敏感操作
- 敏感信息处理：
  - 手机号/验证码/二次密码：绝不写日志、绝不落盘
  - session 文件/字符串：只保存在挂载卷中，权限收紧；必要时可加密（第二阶段再做也可以）
- 默认策略：
  - 默认关闭“公网直接访问 Python 服务端口”，仅让反向代理暴露 443
  - 默认限制“导出配置/下载日志”等操作需要二次确认（防误触）
- 建议的额外加固（公网强烈建议做，且成本很低）：
  - 只在反向代理暴露端口（`app` 不映射到宿主机端口）
  - 登录与敏感接口做限速/冷却（防爆破）
  - 应用内会话 Cookie：`HttpOnly`、`Secure`、`SameSite`，并开启 CSRF 防护（表单/写接口）
  - 若部署平台不提供白名单/访问保护：必须在应用内实现 BasicAuth（承担“外层”），同时做失败冷却/限速

### 14.6 任务运行策略（同进程 vs 子进程）

两种可选实现路线（先设计，已拍板选择路线 Y）：

- 路线 X（实现最快）：同进程后台任务
  - FastAPI 启动时创建 WorkerManager，在同一事件循环里跑任务
  - 要求：Uvicorn 单进程单 worker（避免多进程导致任务重复）
  - 适合 MVP、单用户、小并发
- 路线 Y（已选，更稳、更易停）：子进程/独立 worker
  - Web 仅负责下发“启动/停止”命令，worker 子进程跑真正任务
  - 崩溃隔离更好，停止/重启更可靠，日志也更易收集
  - 适合长期公网运行

#### 14.6.1 子进程模型的关键约束（核心）

- 每次运行生成唯一 `run_id`，并把该 run 的：
  - 元数据（task/account/mode/时间/状态/错误）持久化
  - 日志落到独立文件（按 `run_id` 分流）
- Web 负责“编排与监督”，worker 只负责“执行与写日志/退出码”。

#### 14.6.2 WorkerManager 与 worker 的职责边界

- WorkerManager（Web 内）负责：
  - 创建 `Run` 记录并置为 `queued/running`
  - 拉起子进程（携带 `run_id`、task、account、workdir、session_dir、mode 等参数）
  - 监听子进程退出，回写 `success/failed/stopped` 与 `finished_at`
  - 停止：先优雅停止（SIGINT），超时后强杀（SIGTERM/SIGKILL）
  - 崩溃恢复：Web 重启后扫描“未结束 run”，按 PID/心跳判定并修正状态
- worker 子进程负责：
  - 只做一件事：执行某个 `run_id` 对应的任务，并把日志写到指定位置
  - 退出时返回明确 exit code（0 成功，非 0 失败/被停止）

#### 14.6.3 并发与锁（避免 session 冲突）

- 同一个 `account_name` 同时只允许一个 worker 运行（会话文件与 Telegram 连接资源会冲突）。
- 允许不同账号并发；任务并发上限可配置（防止服务器资源被打满）。

#### 14.6.4 Docker 运行建议（避免僵尸进程）

- 由于会产生子进程，容器建议带 init（如 `docker run --init` 或镜像内用 `tini`）以便正确回收子进程。

### 14.7 部署建议（Docker 化视角）

部署分两种常见场景：

- 场景 A（容器平台/托管 Ingress）：平台给域名并绑定端口
  - 只部署 `app` 容器即可，TLS/反代由平台负责
  - 外层鉴权优先用平台提供的访问保护；如果平台不支持，则由应用内 BasicAuth 中间件承担“外层”
  - 若平台无持久化卷：必须启用 WebDAV 备份/拉取作为持久化方案（接受最终一致与可能丢少量数据）
- 场景 B（自管服务器）：用 `docker compose` 拆两层
  - `app`：Python Web + Worker（挂载 `/data` 卷，里面包含 workdir、sessions、logs）
  - `proxy`：Nginx/Caddy（TLS + BasicAuth + 反代到 app）

关键运行约束：

- Python Web 进程建议先以“单 worker”运行（减少并发竞态；后续要扩展再引入分布式锁/队列）
- 反代层负责证书与外层 BasicAuth；应用内登录负责二次保护与细粒度授权

---

## 15. 建议的 MVP 范围（先把“能用”做到位）

第一阶段只做这些也能替代终端：

1) Web 内 Telegram 账号登录（分步向导，覆盖验证码与二次密码）
2) 任务配置的 CRUD（创建/编辑/导入/导出/校验）
3) 运行与停止（run/run-once，至少能看到成功/失败原因）
4) 运行历史 + 日志流（能排障）

其余（可视化编排、图表看板、多账号并行看板、更复杂的监控配置）放到第二阶段。

## 16. 进一步设计文档（草案）

- Web API 合约草案：`docs/web-openapi-draft.md`
- Docker + 域名部署草案（两层鉴权 + 子进程 worker）：`docs/web-deploy-docker-draft.md`
